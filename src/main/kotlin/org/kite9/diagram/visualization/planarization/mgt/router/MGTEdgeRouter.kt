package org.kite9.diagram.visualization.planarization.mgt.router

import org.kite9.diagram.common.algorithms.ssp.NoFurtherPathException
import org.kite9.diagram.common.elements.edge.AbstractPlanarizationEdge
import org.kite9.diagram.common.elements.edge.Edge
import org.kite9.diagram.common.elements.edge.PlanarizationEdge
import org.kite9.diagram.common.elements.mapping.ConnectionEdge
import org.kite9.diagram.common.elements.mapping.ContainerLayoutEdge
import org.kite9.diagram.common.elements.mapping.ElementMapper
import org.kite9.diagram.common.elements.vertex.EdgeCrossingVertex
import org.kite9.diagram.common.elements.vertex.Vertex
import org.kite9.diagram.common.objects.Pair
import org.kite9.diagram.logging.Kite9Log
import org.kite9.diagram.logging.Logable
import org.kite9.diagram.logging.LogicException
import org.kite9.diagram.model.DiagramElement
import org.kite9.diagram.model.position.Direction
import org.kite9.diagram.visualization.planarization.Tools
import org.kite9.diagram.visualization.planarization.mgt.BorderEdge
import org.kite9.diagram.visualization.planarization.mgt.MGTPlanarization
import org.kite9.diagram.visualization.planarization.mgt.MGTPlanarizationImpl
import org.kite9.diagram.visualization.planarization.mgt.builder.MGTPlanarizationBuilder.Companion.logPlanarEmbeddingDetails
import org.kite9.diagram.visualization.planarization.mgt.router.AbstractRouteFinder.*
import org.kite9.diagram.visualization.planarization.mgt.router.AbstractRouteFinder.Companion.getCorrectEdgeSet

/**
 * Contains the logic needed to insert a route generated by the [AbstractRouteFinder] class into an
 * [MGTPlanarization].
 *
 * @author robmoffat
 */
class MGTEdgeRouter(private val rh: RoutableReader, private val em: ElementMapper) : EdgeRouter, Logable {
    var t = Tools()
    var vertexIntro = 0
    var log = Kite9Log.instance(this)
    private fun applyRoute(ci: PlanarizationEdge, best: EdgePath, ep: EdgePath, p: MGTPlanarization): Boolean {
        var ci = ci
        var ep: EdgePath? = ep
        var currentAbove = true
        var lastVertexTemp: Vertex? = null
        try {
            while (ep != null) {
                log.send(if (log.go()) null else "Handling: $ep")
                if (ep is StartPath) {
                    val start = ep.l.vertex
                    if (start !== ci.getFrom()) {
                        // this occurs when we route container-meeting vertices.
                        ci.getFrom().removeEdge(ci)
                        ci.setFrom(start)
                        start.addEdge(ci)
                    }
                    insertEdge(currentAbove, ci, p, ep.outsideEdge)
                } else if (ep is EdgeCrossPath) {
                    // edge crossing
                    val crossedEdge = ep.crossing
                    val crossingVertex = createCrossingVertex(crossedEdge, ci)
                    val brokenCross = t.splitEdge(crossedEdge, crossingVertex, p)
                    val vertexTo = p.getVertexIndex(lastVertexTemp!!)
                    var crossToPosition = p.getVertexIndex(crossedEdge.getTo())
                    var crossFromPosition = p.getVertexIndex(crossedEdge.getFrom())
                    if (crossToPosition < crossFromPosition) {
                        val temp = crossToPosition
                        crossToPosition = crossFromPosition
                        crossFromPosition = temp
                    }
                    val currentlyOutsideEdge = vertexTo > crossToPosition || vertexTo < crossFromPosition
                    val crossingSideAbove = p.aboveLineEdges.contains(crossedEdge)
                    var place: Int
                    if (crossingSideAbove != currentAbove) {
                        throw LogicException("Next edge should be on the same side as the crossing edge")
                    }
                    if (!currentlyOutsideEdge) {
                        // vertexTo is coming up from below ground, we are breaking outside of a rainbow
                        place = safeSiteInside(
                            best,
                            crossedEdge,
                            vertexTo,
                            crossFromPosition,
                            crossToPosition,
                            ep.going === Going.FORWARDS,
                            p,
                            crossingSideAbove
                        )
                        currentAbove = crossingSideAbove
                    } else {
                        // vertexTo is outside the rainbow, wanting to push into it 
                        place = safeSiteOutside(
                            best, currentAbove, crossedEdge, crossToPosition, crossFromPosition,
                            ep.going === Going.FORWARDS, p, crossingSideAbove
                        )
                    }
                    val parts = t.splitEdge(ci, crossingVertex, p)
                    insertVertices(place, ep.prev, p, crossingVertex)
                    ci = parts.a
                    removeEdge(crossedEdge, p, crossingSideAbove)
                    if (crossingSideAbove) {
                        insertEdge(true, brokenCross.a, p, null)
                        insertEdge(true, brokenCross.b, p, null)
                    } else {
                        insertEdge(false, brokenCross.a, p, null)
                        insertEdge(false, brokenCross.b, p, null)
                    }
                    insertEdge(currentAbove, parts.b, p, if (crossToPosition > vertexTo) brokenCross.b else null)
                    replaceReferences(crossedEdge, brokenCross.a, brokenCross.b, best)
                    currentAbove = crossingSideAbove
                    lastVertexTemp = crossingVertex
                } else if (ep is PlanarizationCrossPath) {
                    val crossing = ep.crossingPoint
                    // side cross
                    val parts = t.splitEdge(ci, crossing, p)
                    ci = parts.a
                    if (currentAbove) {
                        insertEdge(true, parts.b, p, null)
                    } else {
                        insertEdge(false, parts.b, p, null)
                    }
                    lastVertexTemp = crossing
                    currentAbove = !currentAbove
                } else if (ep is FinishPath) {
                    val end = ep.l.vertex
                    if (ci.getTo() !== end) {
                        // this occurs when we route container-meeting vertices.
                        ci.getTo().removeEdge(ci)
                        ci.setTo(end)
                        end.addEdge(ci)
                    }
                    currentAbove = ep.side === PlanarizationSide.ENDING_ABOVE
                    lastVertexTemp = end
                } else {
                    throw LogicException("Simple Edge Path?,$ep")
                }
                ep = ep.prev
            }
        } finally {
            log.send(if (log.go()) null else "Inserted: $ci")
            log.send(
                if (log.go()) null else (p as MGTPlanarizationImpl).getTextualRepresentation(ci.getDiagramElements().keys)
                    .toString()
            )
        }
        return true
    }

    private fun safeSiteInside(
        best: EdgePath, cross: PlanarizationEdge, vertexTo: Int, startVertex: Int, endVertex: Int,
        forwards: Boolean, p: MGTPlanarization, crossingSideAbove: Boolean
    ): Int {
        val end = p.vertexOrder[endVertex]
        val start = p.vertexOrder[startVertex]
        return if (forwards) {
            safeSiteForwards(
                cross,
                getCorrectEdgeSet(vertexTo, startVertex, crossingSideAbove, start, p),
                startVertex, p.vertexOrder[startVertex], crossingSideAbove, best, p
            )
        } else {
            safeSiteBackwards(
                cross,
                getCorrectEdgeSet(vertexTo, endVertex, crossingSideAbove, end, p),
                endVertex, p.vertexOrder[endVertex], crossingSideAbove, best, p
            )
        }
    }

    private fun safeSiteOutside(
        best: EdgePath, currentAbove: Boolean, cross: PlanarizationEdge, endVertex: Int, startVertex: Int,
        forwards: Boolean, p: MGTPlanarization, crossingAbove: Boolean
    ): Int {
        val end = p.vertexOrder[endVertex]
        val start = p.vertexOrder[startVertex]
        return if (forwards) {
            safeSiteBackwards(
                cross,
                if (crossingAbove) p.getAboveBackwardLinks(end) else p.getBelowBackwardLinks(end),
                endVertex, p.vertexOrder[endVertex], currentAbove, best, p
            )
        } else {
            safeSiteForwards(
                cross,
                if (crossingAbove) p.getAboveForwardLinks(start) else p.getBelowForwardLinks(start),
                startVertex, p.vertexOrder[startVertex], currentAbove, best, p
            )
        }
    }

    private fun insertVertices(at: Int, ep: EdgePath?, p: MGTPlanarization, vararg vs: Vertex) {
        for (crossing in vs) {
            p.addVertexToOrder(at, crossing)
            log.send("Inserted vertex $at   $crossing")
        }
    }

    private fun createCrossingVertex(e2: PlanarizationEdge, e1: PlanarizationEdge): Vertex {
        val underlyings: MutableSet<DiagramElement> = HashSet(e1.getDiagramElements().keys)
        underlyings.addAll(e2.getDiagramElements().keys)
        return EdgeCrossingVertex("ecv" + vertexIntro++, underlyings)
    }

    /**
     * Ensures that we can add a vertex after vertex index without crashing any existing edges.
     */
    private fun safeSiteForwards(
        cross: PlanarizationEdge,
        list: List<PlanarizationEdge>,
        vertexIndex: Int,
        v: Vertex,
        aboveEdges: Boolean,
        ep: EdgePath,
        p: MGTPlanarization
    ): Int {
        var index = list.indexOf(cross)
        if (index == -1) {
            throw LogicException("Was expecting $cross in $list at index $vertexIndex")
        }
        if (index > 0) {
            var i = 0
            while (i < index) {
                val around = list[i]
                val crossing: Vertex = PlanarizationCrossingVertex("x" + vertexIntro++)
                var parts: Pair<PlanarizationEdge> = t.splitEdge(around, crossing, p)
                insertVertices(vertexIndex, ep.prev, p, crossing)
                removeEdge(around, p, aboveEdges)

                // make sure parts is ordered in same direction as planarization
                if (p.getVertexIndex(around.getFrom()) > p.getVertexIndex(around.getTo())) {
                    parts = Pair(parts.b, parts.a)
                }
                replaceReferences(around, parts.b, parts.a, ep)
                if (aboveEdges) {
                    insertEdge(false, parts.a, p, null)
                    insertEdge(true, parts.b, p, null)
                } else {
                    insertEdge(true, parts.a, p, null)
                    insertEdge(false, parts.b, p, null)
                }
                i = i - 1
                index--
                i++
            }
        }
        return vertexIndex
    }

    /**
     * Ensures that we can add a vertex before vertex index without crashing any existing edges.
     */
    private fun safeSiteBackwards(
        cross: PlanarizationEdge,
        list: List<PlanarizationEdge>,
        vertexIndex: Int,
        v: Vertex,
        aboveEdges: Boolean,
        ep: EdgePath,
        p: MGTPlanarization
    ): Int {
        var index = list.indexOf(cross)
        var outIndex = vertexIndex - 1
        if (index == -1) {
            throw LogicException("Was expecting $cross in $list at index $vertexIndex")
        }
        if (index > 0) {
            var i = 0
            while (i < index) {
                val around = list[i]
                val crossing: Vertex = PlanarizationCrossingVertex("x" + vertexIntro++)
                var parts: Pair<PlanarizationEdge> = t.splitEdge(around, crossing, p)

                // make sure parts is ordered in same direction as planarization
                if (p.getVertexIndex(around.getFrom()) > p.getVertexIndex(around.getTo())) {
                    parts = Pair(parts.b, parts.a)
                }
                insertVertices(outIndex, ep.prev, p, crossing)
                removeEdge(around, p, aboveEdges)
                replaceReferences(around, parts.a, parts.b, ep)
                if (aboveEdges) {
                    insertEdge(true, parts.a, p, null)
                    insertEdge(false, parts.b, p, null)
                } else {
                    insertEdge(false, parts.a, p, null)
                    insertEdge(true, parts.b, p, null)
                }
                i = i - 1 // removing the edge means we should go back a
                // place in the array
                index--
                outIndex++
                i++
            }
        }
        return outIndex
    }

    private fun replaceReferences(
        from: PlanarizationEdge,
        to: PlanarizationEdge?,
        other: PlanarizationEdge?,
        ep: EdgePath
    ) {
        var ep: EdgePath? = ep
        while (ep != null) {
            if (ep is EdgeCrossPath) {
                if (ep.crossing === from) {
                    ep.crossing = to!!
                }
            } else if (ep is StartPath) {
                val outsideOf = ep.outsideEdge
                val start = ep.l.vertex
                if (outsideOf === from) {
                    if (to!!.meets(start)) {
                        ep.outsideEdge = to
                    } else if (other!!.meets(start)) {
                        ep.outsideEdge = other
                    } else {
                        throw LogicException("Can't fix up start path")
                    }
                }
            }
            ep = ep.prev
        }
    }

    override fun addPlanarizationEdge(
        p: MGTPlanarization,
        ci: PlanarizationEdge,
        d: Direction?,
        it: CrossingType,
        gt: GeographyType
    ): Boolean {
        return try {
            logPlanarEmbeddingDetails(p, log)
            val f = if (ci is ContainerLayoutEdge) LayoutEdgeRouteFinder(
                p,
                rh,
                ci,
                em,
                d!!
            ) else if (ci is BorderEdge) ContainerEdgeRouteFinder(p, rh, ci) else ConnectionEdgeRouteFinder(
                p,
                rh,
                (ci as ConnectionEdge),
                em,
                d,
                it,
                gt
            )
            log.send("Routing " + ci + " from " + ci.getFrom() + " to " + ci.getTo() + "d=" + ci.getDrawDirection())
            val ep: EdgePath = f.createShortestPath()
            if (ep.costing.illegalEdgeCrossings > 0) {
                if (it === CrossingType.STRICT) {
                    return false
                }
            }
            log.send(if (log.go()) null else "Routed $ci: $ep")
            removeDuplicates(ep, p)
            createPlaneCrossingVertices(ep, p)
            if (ep.costing.minimumExpensiveAxisDistance > 0 && ci is PlanarizationEdge) {
                (ci as AbstractPlanarizationEdge).setStraight(false)
            }
            applyRoute(ci, ep, ep, p)
            true
        } catch (nfe: NoFurtherPathException) {
            log.error("Could not route " + ci + " in direction " + ci.getDrawDirection())
            false
        } catch (ere: EdgeRoutingException) {
            log.error("Could not route $ci", ere)
            false
        }
    }

    private fun removeDuplicates(start: EdgePath, p: MGTPlanarization) {
        var start: EdgePath? = start
        val onStack = ArrayDeque<EdgePath>()
        while (start != null) {
            if (onStack.size > 0) {
                var top = onStack.first()
                while (top!!.sameCrossing(start)) {
                    onStack.removeFirst()
                    log.send("Removing duplicates: $top and $start")
                    top = onStack.first()
                    top!!.prev = start!!.prev
                    start = start.prev
                }
            }
            onStack.add(start!!)
            start = start!!.prev
        }
    }

    private fun createPlaneCrossingVertices(ep: EdgePath?, p: MGTPlanarization) {
        // create vertices in the planarization for the edge crossings
        if (ep is PlanarizationCrossPath) {
            val beforeStart = ep.beforeV
            val beforeI = p.getVertexIndex(beforeStart)
            // insert the vertex after beforeI
            val crossing: Vertex = PlanarizationCrossingVertex("x" + vertexIntro++)
            insertVertices(beforeI, ep.prev, p, crossing)
            ep.crossingPoint = crossing
            log.send("Crossing Vertex created: $crossing for $ep")
        }
        if (ep!!.prev != null) {
            createPlaneCrossingVertices(ep.prev, p)
        }
    }

    private fun insertEdge(
        above: Boolean,
        edge: PlanarizationEdge?,
        p: MGTPlanarization,
        outsideOf: PlanarizationEdge?
    ) {
        if (!p.crosses(edge!!, above)) {
            p.addEdge(edge, above, outsideOf)
            log.send("Inserted edge: " + edge + " going " + edge.getDrawDirection())
        } else {
            throw LogicException("Could not route edge: $edge")
        }
    }

    private fun removeEdge(cross: Edge, p: MGTPlanarization, above: Boolean) {
        p.removeEdge(cross)
    }

    override val prefix: String
        get() = "MGER"
    override val isLoggingEnabled: Boolean
        get() = false
}